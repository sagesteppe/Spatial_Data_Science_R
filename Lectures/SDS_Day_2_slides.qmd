---
title: "R Data Science: Spatial Data Science II"
subtitle: "R for Data Science"
author: "Reed Benkendorf"
date: "2022-February-11"
date-format: long
format: 
  revealjs:
    theme: black
    highlight: pygments
    preview-links: auto
    logo: ../pictures/CBG_Logos/NegauneeInstitute_CBG-Logo-FlowerMark.png
    chalkboard: 
      boardmarker-width: 5
    reveal_options:
      width: 1920
      height: 1080
      fontsize: 22pt
css: custom.css
editor: 
  markdown: 
    wrap: 72
include-in-header:
  - text: |
      <style>
      #title-slide .title {
        font-size: 1.5em;
      }
      #image tags .center {
        text-align: center;
        font-size: 4em;
        font-color: cbc4c3;
      }
      </style>
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, comment = "", fig.align="center")
```

## {background-image=../pictures/Pioneer_Mtns_ID.jpg}

::: {style="float: center; width: 80%; font-size: 1.1em; color: #2f2d2d ; text-align: center;"}
Assigned Reading: Chapter 3 of Spatial Data Science
:::

```{r Load Libraries}
shhh <- suppressPackageStartupMessages #  silence messages.

shhh(library(tidyverse))
shhh(library(raster))
shhh(library(terra))
shhh(library(sf))
shhh(library(spData))
shhh(library(parallel))
shhh(library(fields))
shhh(library(spdep))
shhh(library(gstat))
shhh(library(spatstat))

source('../scripts/functions.R')
rm(shhh)
```

```{r Import Chicago Neighborhoods Polygons}
files <- paste0('../spatial_lecture_data/Chicago_Neighborhoods/',
                list.files('../spatial_lecture_data/Chicago_Neighborhoods', ".shp"))
chi_neighb <- read_sf(files)
rm(files)
```

```{r Import Chicago Park District Polygons, cache = T}
files <- paste0('../spatial_lecture_data/Chicago_Park_District_Park_Boundaries/' ,
                list.files('../spatial_lecture_data/Chicago_Park_District_Park_Boundaries', ".shp"))
chi_parks <- read_sf(files) %>% 
  dplyr::select(acres, park, park_class) %>% 
  st_make_valid() %>% 
  st_simplify(dTolerance = 100)

chi_neighb1 <- st_intersection(chi_neighb, chi_parks)
park_areas <- chi_neighb1 %>% 
  mutate(areas = as.numeric(st_area(.))/1000) %>% 
  group_by(pri_neigh) %>% 
  mutate(total_park_area = sum(areas)) %>% 
  distinct(pri_neigh, .keep_all = T) %>% 
  st_drop_geometry() %>% 
  dplyr::select(pri_neigh, total_park_area)

rm(files, chi_neighb1)
```

```{r Create Museum Dummy Data}
AM <- as_tibble(cbind(attribute = 'American',
                latitude = 40.781563, 
                longitude = -73.974751)) %>% 
  st_as_sf(coords = c(x = 'longitude', y = 'latitude'), 
           crs = 4326, remove = F)
FM <- as_tibble(cbind(attribute = 'Field',
                latitude = 41.866662,
                longitude = -87.616433)) %>% 
  st_as_sf(coords = c(x = 'longitude', y = 'latitude'), 
           crs = 4326, remove = F)
SM <- as_tibble(cbind(attribute = 'Smithsonian',
                latitude = 38.890766,
                longitude = -77.025666)) %>% 
  st_as_sf(coords = c(x = 'longitude', y = 'latitude'), 
           crs = 4326, remove = F)

```


```{r Create Polygons to test spatial predicates}

A <- st_polygon( # complete
  list(
    rbind(
      c(1,2), c(3,4), c(3.5,3), c(3.5,2),
      c(3,1), c(1,2) 
    )
  )
)

B_disjoint <- st_polygon( # complete
  list(
    rbind(
      c(3.25,4.25), c(3.75,3.25), c(3.75,2.25),
      c(5.25,4.25), c(3.25,4.25)
    )
  )
)

B_touches <- st_polygon( # complete
  list(
    rbind(
      c(3,4), c(3.5,3), c(3.5,2),
      c(5,4), c(3,4)
    )
  )
)

B_overlap <- st_polygon( # complete
  list(
    rbind(
      c(3,2.5), c(3.5,1.5), c(3.5,0.5),
      c(5,2.5), c(3,2.5)
    )
  )
)

B_covers <- st_polygon( # complete
  list(
    rbind(
      c(2.75,3), c(3.5,3), c(3.5,2),
      c(2.75,2), c(2.75,3)
    )
  )
)

B_contains <- st_polygon( # complete
  list(
    rbind(
      c(2.25,3), c(3,3), c(3,2),
      c(2.25,2), c(2.25,3)
    )
  )
)

B_equals <- st_polygon( # complete
  list(
    rbind(
      c(1,2), c(3,4), c(3.5,3), c(3.5,2),
      c(3,1), c(1,2) 
    )
  )
)


disjoint_plot <- ggplot() +
   geom_sf(data = A, fill = "deeppink1", lty = 3) +
   geom_sf(data = B_disjoint, fill = "deepskyblue2", lty = 5) +
   xlim(0, 5) +
   ylim(0, 5) +
   labs(title="Disjoint") +
   theme_classic() +
   theme(plot.title = element_text(hjust = 0.5), 
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())
   
touches_plot <- ggplot() +
   geom_sf(data = A, fill = "deeppink1", lty = 3) +
   geom_sf(data = B_touches, fill = "deepskyblue2", lty = 5) +
   xlim(0, 5) +
   ylim(0, 5) +
   labs(title="Touches") +
   theme_classic() +
   theme(plot.title = element_text(hjust = 0.5),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())

overlap_plot <- ggplot() +
   geom_sf(data = A, fill = "deeppink1", lty = 3) +
   geom_sf(data = B_overlap, fill = "deepskyblue2", lty = 5) +
   xlim(0, 5) +
   ylim(0, 5) +
   labs(title="Overlaps") +
   theme_classic() +
   theme(plot.title = element_text(hjust = 0.5),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())

covers_plot <- ggplot() +
   geom_sf(data = A, fill = "deeppink1", lty = 3) +
   geom_sf(data = B_covers, fill = "deepskyblue2", lty = 5) +
   xlim(0, 5) +
   ylim(0, 5) +
   labs(title="Covers") +
   theme_classic() +
   theme(plot.title = element_text(hjust = 0.5),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())

contains_plot <- ggplot() +
   geom_sf(data = A, fill = "deeppink1", lty = 3) +
   geom_sf(data = B_contains, fill = "deepskyblue2", lty = 5) +
   xlim(0, 5) +
   ylim(0, 5) +
   labs(title="Contains") +
   theme_classic() +
   theme(plot.title = element_text(hjust = 0.5),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())

equals_plot <- ggplot() +
   geom_sf(data = A, fill = "deeppink1", lty = 3) +
   geom_sf(data = B_equals, fill = "deepskyblue2", lty = 5) +
   xlim(0, 5) +
   ylim(0, 5) +
   labs(title="Equals") +
   theme_classic() +
   theme(plot.title = element_text(hjust = 0.5),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())
```

# Topology

Many/Most geographic operations are geometric in nature

## Theoretical Relations I 

::: {style="float: left; width: 50%;"}
- Dimensionally Extended 9-Intersection Model (DE-9IM) 
- Developed to query spatial databases
- Serves as the standard for describing relations
:::

::: {style="float: right; width: 50%; font-size: 0.8em; color: #cbc4c3; text-align: center;"}
```{r, out.width = "85%", fig.show='hold', fig.cap = "DE-9IM (Krauss)", out.height="50%"}
knitr::include_graphics('../pictures/DE-9IM_By_Krauss.png')
```

:::

## Theoretical Relations II 

::: {style="float: left; width: 50%;"}

<font size = "5">

Upper Middle Panel, dimensions containing the intersection of the **Interior** of 'A' to the **Boundary** of 'B' is equal to a line. 

$$
dim[I(a)∩B(b)] = 1
$$

where 'I' is the 'Interior' (of 'A') & 'B' is the 'Boundary' (of 'B')

$$
\text{∩ is the 'Intersection'}
$$

'1' denotes that the product of the intersection is a line - it's the maximal dimension when intersecting to a boundary! 
</font> 

:::

::: {style="float: right; width: 50%; font-size: 0.8em; color: #cbc4c3; text-align: center;"}
```{r, out.width = "85%", fig.show='hold', echo = F, fig.cap = "DE-9IM (Krauss)", fig.align="center", out.height="50%"}
knitr::include_graphics('../pictures/DE-9IM_By_Krauss.png')
```
:::


## Applications

::: {style="float: left; width: 60%;"}

<font size="5">
A schema for describing spatial relationships  
</font> 

<font size="4">

$dim[I(a)∩I(b)] = 2$    Which areas are in both polygons   
$dim[I(a)∩B(b)] = 1$    Which areas are in 'a', and the boundary of 'b'   
$dim[I(a)∩E(b)] = 2$    Which areas are in 'a', but not in 'b'  

$dim[B(a)∩I(b)] = 1$    Which areas are at the boundary of 'a', and in 'b'  
$dim[B(a)∩B(b)] = 0$    Which areas are at the boundaries of 'a' and 'b'  
$dim[B(a)∩E(b)] = 1$    Which areas are at the boundary of 'a', and outside 'b'  

$dim[E(a)∩I(b)] = 2$    Which areas are in 'b' but not in 'a'  
$dim[E(a)∩B(b)] = 1$    Which areas are at the boundary of 'b' and outside 'a'  
$dim[E(a)∩E(b)] = 2$    Which areas are outside both 'a' and 'b'  

</font> 
:::

::: {style="float: right; width: 40%; font-size: 0.8em; color: #cbc4c3; text-align: center;"}
```{r, out.width = "85%", fig.show='hold', echo = F, fig.cap = "DE-9IM (Krauss)", fig.align="center", out.height="50%"}
knitr::include_graphics('../pictures/DE-9IM_By_Krauss.png')
```
:::

# Geometric Operations on Spatial Predicates

## Theoretical Properties

::: {style="float: center; width: 100%; font-size: 0.6em; color: #cbc4c3; text-align: center;"}

```{r Plot Topology, echo = F, fig.cap = "Spatial Predicates after Egenhofer and Herring (1990)", out.width="50%"}
cowplot::plot_grid(disjoint_plot, touches_plot, overlap_plot, covers_plot, contains_plot, equals_plot, labels = NULL, ncol = 3)

rm(contains_plot, covers_plot, disjoint_plot, equals_plot, overlap_plot, touches_plot)
```

:::

:::: {.columns}
::: {.column width = '55%'}
<font size="5">
**Disjoint** Neither 'A' nor 'B' touch at any position  
**Touches** The boundaries of 'A' and 'B' touch  
**Overlaps** Portions of the interior of feature 'A' overlap the interior of 'B'  
</font> 
:::

::: {.column width = '45%'}
<font size="5">
**Covers** 'A' is encapsulated by 'B' several sides, but a boundary of 'A' shares a border with 'B'  
**Contains** All borders of one feature are contained by another  
**Equals** 'A' and 'B' have identical extents.  
</font> 
:::
::::

## Implementations 

postGIS implements the following three tests in addition to those on the previous slide:  

- **Intersects** (includes: 'st_touches', 'st_overlaps', 'st_covers', 'st_contain', 'st_equals')  
- **Within** (includes: 'st_contains')  
- **CoveredBy** (includes: 'st_equals')  

## Applications

- Relationships can be tested using the sf package

<details> 
<summary>sf implementation</summary>

```{r Spatial Predicates in SF, comment = "", echo = F}

writeLines(paste0('st_disjoint(A, B_disjoint, sparse = F): ', st_disjoint(A, B_disjoint, sparse = F)[1,1]))
writeLines(paste0('st_touches(A, B_touches, sparse = F): ', st_touches(A, B_touches, sparse = F)[1,1]))
writeLines(paste0('st_equals(A, B_overlap, sparse = F): ', st_overlaps(A, B_overlap, sparse = F)[1,1]))
writeLines(paste0('st_covers(A, B_covers, sparse = F): ',  st_covers(A, B_covers, sparse = F)[1,1]))
writeLines(paste0('st_contains(A, B_contains, sparse = F): ', st_contains(A, B_contains, sparse = F)[1,1]))
writeLines(paste0('st_equals(A, B_equals, sparse = F): ', st_equals(A, B_equals, sparse = F)[1,1]))
writeLines(paste0('st_equals(A, B_disjoint, sparse = F): ', st_equals(A, B_disjoint, sparse = F)[1,1]))

```

</details>

<details> 
<summary>postGIS implementation</summary>

```{r Spatial Predicates in SF 2, comment = "", echo = F}
writeLines(paste0('st_intersects(A, B_touches, sparse = F): ', st_intersects(A, B_touches, sparse = F)[1,1]))
writeLines(paste0('st_intersects(A, B_overlap, sparse = F): ', st_intersects(A, B_overlap, sparse = F)[1,1]))
writeLines(paste0('st_intersects(A, B_covers, sparse = F): ', st_intersects(A, B_covers, sparse = F)[1,1]))
writeLines(paste0('st_intersects(A, B_contains, sparse = F): ', st_intersects(A, B_contains, sparse = F)[1,1])) 
writeLines(paste0('st_intersects(A, B_equals, sparse = F): ', st_intersects(A, B_equals, sparse = F)[1,1]))

writeLines(paste0('st_within(A, B_contains, sparse = F): ', st_within(A, B_contains, sparse = F)[1,1])) # opposite!
writeLines(paste0('st_within(B_contains, A, sparse = F): ', st_within(B_contains, A, sparse = F)[1,1])) # there we go!

writeLines(paste0('st_coveredby(A, B_equals, sparse = F): ', st_covered_by(A, B_equals, sparse = F)[1,1]))

rm(A, B_disjoint, B_contains, B_covers, B_equals, B_overlap, B_touches)
```

</details>

## Spatial Join

Combine objects based on their spatial relations. 

```{r Spatial Joins 1, comment = "", message = F, warning = F, echo = TRUE}
nghbrhd_parks <- st_join(
  chi_neighb, chi_parks, 
  join = st_intersects, 
  left = TRUE) %>% 
  count(pri_neigh) 
```

::: {style="float: center; width: 75%; font-size: 0.6em; color: #cbc4c3; text-align: center;"}

```{r Spatial Joins 2, comment = "", message = F, warning = F, echo = F, out.height="10%"}
bound <- st_bbox(chi_neighb)
    
a <- ggplot(chi_neighb) +
  geom_sf(fill = "#B3DDF2") + 
  coord_sf(xlim = c(bound[1],bound[3]), ylim = c(bound[2],bound[4])) +
  labs(title = 'Neighborhoods') +
  theme_void()  

b <- ggplot(chi_parks) + 
  geom_sf(fill = "#FF0000") +
  coord_sf(xlim = c(bound[1],bound[3]), ylim = c(bound[2],bound[4])) +
  labs(title = 'Parks') +
  theme_void()
  
c <- ggplot() + 
  geom_sf(data = nghbrhd_parks, aes(fill = n)) + 
  coord_sf(xlim = c(bound[1],bound[3]), ylim = c(bound[2],bound[4])) +
  theme_void() +
  labs(title = 'Park per Neighborhood') +
  theme(legend.position = "none")

cowplot::plot_grid(a, b, c, ncol = 3)

rm(bound, a, b, c)
```

:::

# Assorted Spatial Vector Operations

This is really a grab bag of what I and others seem to use most the often. We are going to focus on vector data. 

## Import a Vector file

Many formats of vector files may be imported to R. Here we import a shapefile, but the process is the same for geopackages etc. 

```{r Import a Vector file, eval = F, echo = TRUE}
#| code-line-numbers: "4"
fp <- file.path('..', 'spatial_lecture_data', 'Chicago_Neighborhoods')
files <- file.path(fp, list.files(fp, ".shp"))

chi_neighb <- read_sf(files)
```

```{r}
rm(files)
```

## Convert to and from sp objects

Often needed to be done on the fly 

```{r convert from-to sp-sf 1, echo = FALSE}
data("us_states", package = "spData")
us_states.sp <- as(us_states, 'Spatial')
```

convert `sp` -> `sf`
```{r convert from-to sp-sf 2, comment = "", echo = TRUE}
#| code-line-numbers: "1"
us_states.sf <- st_as_sf(us_states.sp)
class(us_states.sf)
```

convert `sf` -> `sf` 
```{r convert from-to sp-sf 3, comment = "", echo = TRUE}
#| code-line-numbers: "1"
us_states.sp <- as(us_states.sf, 'Spatial')
class(us_states.sp)
```

## Make tabular point data spatial

```{r make point data spatial 1, echo = FALSE}
museums <- as_tibble(
  cbind(
    attribute = c('Field Museum', 'Science and Industry'),
    latitude  = c( 41.86666,  41.79006),
    longitude = c(-87.61643, -87.58227)
    )
  ) 
```

`coords` columns holding coordinates  
`crs` The CRS the data are currently   
`remove = F` Should the original coordinate holding columns be removed?  

```{r make point data spatial 2, echo = TRUE}
museums.sf <- st_as_sf(
  museums, 
  coords = c(x = 'longitude', y = 'latitude'), 
  crs = 4326, 
  remove = F
  )
```

<font size="5">
```{r make point data spatial 3, echo = F}
knitr::kable(museums.sf)
```
</font>

## `st_transform`

<details> 
<summary>Check CRS</summary>
```{r transform crs 1, echo= TRUE}
st_crs(museums.sf)
```
</details>

project coordinates from one CRS to another. EPSG codes are numeric and simple to use! 
```{r transform crs 2, echo= TRUE}
museums.conus_albers <- st_transform(museums.sf, crs = 5070)
```

verify the projection worked with `st_crs`
```{r transform crs 3, echo = F, comment = "", echo= TRUE}
st_crs(museums.conus_albers)[['input']]
```

## Remove simple feature list column

Oftentimes required to feed a data set into other packages, the list columns can confuse them. 

<font size="5">

```{r drop geometry column 1, echo = TRUE}
head(museums.sf)
```

<br>

```{r drop geometry column 2, echo = TRUE}
museums <- st_drop_geometry(museums.sf) # method one, pipe-able 
st_geometry(museums.sf) <- NULL # method two, drop in place. 
head(museums)
```

```{r drop geometry column 3, echo = F}
rm(museums, museums.sf, museums.conus_albers)
```

</font> 

## Make geometry a valid Simple Feature  

Some spatial data may not be in a simple format
sf package can *generally* fix this 

```{r Make Geometry Valid as a Simple Feature 1}
p1 = st_as_sfc("POLYGON((0 0, 0 10, 10 0, 10 10, 0 0))")
# create a geometry which will not be valid
```

```{r Make Geometry Valid as a Simple Feature 2, eval = F, echo = TRUE}
st_is_valid(p1)
st_is_valid(p1, reason = TRUE)
```

```{r Make Geometry Valid as a Simple Feature 3, echo = F, comment = ""}
writeLines(paste0("st_is_valid(p1): ", st_is_valid(p1))) 
writeLines(paste0("st_is_valid(p1, reason = TRUE): ", st_is_valid(p1, reason = TRUE)))
```

making the geometry simple with st_make_valid()
```{r Make Geometry Valid as a Simple Feature 4, echo = TRUE}
p2 <- st_make_valid(p1)
```

## Make geometry a valid Simple Feature  

Polygon became a multipolygon with two polygons  
Split by removal of self-intersection at position X5, Y5. 

```{r Make Geometry Valid as a Simple Feature 5, echo = F, fig.align="center", comment = ""}
ex <- data.frame(X = p1[[1]][[1]][,1], Y = p1[[1]][[1]][,2])
ex$Name <- paste0("c(", "x = ",  ex$X, ", y = ", ex$Y, ")")
  
ex2 <- data.frame(rbind(X = p2[[1]][[1]][[1]],
                  Y = p2[[1]][[2]][[1]]))
colnames(ex2) <- c('X', 'Y')
ex2$Name <- paste0("c(", "x = ",  ex2$X, ", y = ", ex2$Y, ")")
  
a <- ggplot() +
  geom_sf(data = p1, fill = "darkseagreen")+
  geom_point(data = ex, aes(x = X, y = Y), size = 3) +
  xlim(-10, 15) +
  ylim(-10, 15) +
  theme_bw() +
  ggrepel::geom_label_repel(data = ex, aes(x = X, y = Y,label = Name),
                  box.padding   = 0.5, 
                  point.padding = 0.5,
                  segment.color = 'purple') +
  labs(title = "Non-Valid Geometry") +
  theme(plot.title = element_text(hjust = 0.5))

b <- ggplot() +
  geom_sf(data = p2, fill = "darkseagreen")+
  geom_point(data = ex2, aes(x = X, y = Y), size = 3) +
  xlim(-10, 15) +
  ylim(-10, 15) +
  theme_bw() +
  ggrepel::geom_label_repel(data = ex2, aes(x = X, y = Y,label = Name),
                  box.padding   = 0.5, 
                  point.padding = 0.5,
                  segment.color = 'purple') +
  labs(title = "Valid Geometry") +
  theme(plot.title = element_text(hjust = 0.5))
```

:::: {.columns}
::: {.column width = '50%'}

```{r Check class of objects 1, echo = TRUE}
class(p1)[1]
```
:::

::: {.column width = '50%'}
```{r Check class of objects 2, echo = TRUE}
class(p2)[1]
```
:::
::::

```{r, fig.align="center"}
cowplot::plot_grid(a, b, ncol = 2)

rm(p1, p2, ex, ex2, a,b)
```

## `summarize` geometries with `group_by` 

`dplyr` can be used to union geometries by group  

```{r Summarize 2, echo = TRUE}
regions <- us_states %>%
  group_by(REGION) %>% 
  summarize(geometry = st_union(geometry))
```

:::: {.columns}
::: {.column width = '50%'}

```{r Summarize 3, echo = F}
a <- ggplot(us_states) +
  geom_sf() +
  theme_void()

b <- ggplot(regions) +
  geom_sf() +
  theme_void()

cowplot::plot_grid(a, b, ncol = 1)
```

:::

::: {.column width = '50%'}

<details> 
<summary>input data</summary>
<font size="4">

```{r Summarize 1, echo = F}
knitr::kable(head(us_states[,c(2:3,7)]))
```

</font>
</details>

<details> 
<summary>results</summary>
<font size="4">
```{r Summarize 4, echo = F}
knitr::kable(regions)

rm(a, b, regions)
```

</font> 
</details>

:::
::::

# Area Calculations

calculate the area of a polygon 

```{r Area 1, message = F, eval = F, echo = FALSE}
st_area(chi_neighb)
```

```{r Area 2, message = F, echo = F, comment = "", echo = TRUE}
st_area(chi_neighb)[1:5] # restrict to 5 neighborhoods 
```

Data returned in m^2^ regardless of the CRS. However, different projected CRS will give different results 

```{r Area 3, results = 'hide', comment = "", echo = F, fig.align="center", out.width = "50%"}
areas_proj <- chi_neighb %>% 
  st_transform(32610) %>% 
  st_area() 
# projected CRS UTM

areas_geog <- chi_neighb %>% 
  st_transform(4326) %>% 
  st_area() 
# Geographic CRS

# ensure these are in the same order
areas_proj <- sort(areas_proj)
areas_geog <- sort(areas_geog)

# are all values the same??
which(c(1,4) == c(2,4))
which(areas_proj == areas_geog)

min(areas_geog)
max(areas_proj)

#  what is the correlation between the two methods of measurement?
res <- cor.test(areas_proj, areas_geog,  method="kendall") # tau of 1, perfect correlation
```

```{r}
# what is the relationship.
plot(x = areas_geog, y = areas_proj, pch = 18, xlim = c(min(areas_geog),max(areas_proj)), 
     ylim = c(min(areas_geog), max(areas_proj)), 
     main = "Area of Geographic CRS Polygons plotted against Projected CRS")  
  abline(0,1, lty = 2) 
  text(min(areas_geog)*25, max(areas_proj)*0.975, 
       paste0("tau = ", res[["estimate"]][["tau"]])) +
  text(min(areas_geog)*60, max(areas_proj)*0.90,
       paste0("p-value = ", " < 0.001"))
```

```{r Area 4, message = F, comment = ""}
equal_areas_proj <- chi_neighb %>% 
  st_transform(5070) %>% 
# We want to use an equal area projection! 
  st_area()

equal_areas_proj <- sort(equal_areas_proj)
```

## Area Calculations conversion

Values by converted by looking up constants, or by using the `units` package.

```{r Area 5, comment = "", echo = TRUE}
units(equal_areas_proj) <- units::make_units(ha)
head(equal_areas_proj)
```

:::: {.columns}
::: {.column width = '60%'}

```{r Area - 6, fig.align="center"}

equal_areas_proj <- chi_neighb %>% 
  st_transform(5070) %>% 
# if for some reason need a project system - use equal area! 
  st_area()

areas <- as.numeric(equal_areas_proj)

areas <- cbind(chi_neighb, areas) 
largest <- areas %>% 
  arrange(-areas) %>% 
  slice_head(n = 5) %>% 
  st_drop_geometry() %>% 
  dplyr::select(1,5) 
  
smallest <- areas %>% 
  arrange(areas) %>% 
  slice_head(n = 5) %>% 
  st_drop_geometry() %>% 
  dplyr::select(1,5) %>% 
  dplyr::rename(
    Neigh = pri_neigh,  
    Area = areas) 

cbind(smallest, largest) %>% knitr::kable( 
      booktabs = T, 
      align = c("r"), 
      caption = "Size of the Largest and Smallest Neighborhoods in Chicago", 
      col.names = c("Neighborhood", "Area (ha)","Neighborhood", "Area (ha)")) %>% 
  kableExtra::kable_styling("striped", full_width = F, 
                position = "left", font_size = 12) %>% 
  kableExtra::add_header_above(c("Smallest" = 2, "Largest" = 2)) 

rm( areas_geog, areas_proj, equal_areas_proj, res)
```

:::

::: {.column width = '40%'}

```{r Area 7, warning  = FALSE }

tolabel <- filter(areas, pri_neigh %in% c(smallest$Neigh, largest$pri_neigh))
ggplot() + 
  geom_sf(data = areas, aes(fill = areas)) + 
  ggsflabel::geom_sf_label_repel(
    data = tolabel, 
    alpha = 0.8,
    aes(label = pri_neigh),
    segment.color = 'black') + 
  scale_fill_viridis_c('Area (ha)', option = "plasma") + 
  labs(title = 'Area of Neighborhoods') + 
  theme_void() 

rm(areas, smallest, largest)
```

:::
::::

## `st_length` of linestring

- Calculate the length of a linestring

```{r Length 1, message = F, echo = F}
NU_campuses <- st_linestring( 
    rbind(
      c(-87.676,42.057), # tech
      c(-87.621,41.895) # loop campus
    )
  ) %>% 
  st_sfc() %>% 
  st_as_sf(crs = 4326)
```

:::: {.columns}
::: {.column width = '60%'}
```{r Length 2, message = F, comment = "", echo = TRUE}
st_length(NU_campuses)
```
:::

::: {.column width = '40%'}

```{r}
lake_neighs <- chi_neighb[unlist(sf::st_intersects(NU_campuses, st_transform(chi_neighb, st_crs(NU_campuses)))),]
ggplot() + 
  geom_sf(data = lake_neighs) + 
  geom_sf(data = NU_campuses) +
  labs(title = 'A linestring between Campuses') + 
  theme_bw()
```

:::
::::

## Boundary length calculation 

- extract the boundary of the polygon as a linestring  
- calculate length using `st_length` 

```{r Boundary 1, comment = "", echo = TRUE, results = 'hide'}
#| code-line-numbers: "6"
rogers_park <- filter(chi_neighb, pri_neigh == 'Rogers Park')

rogers_park <- st_cast(rogers_park, to = 'MULTILINESTRING')
rogers_park <- st_cast(rogers_park, to = 'LINESTRING')

st_length(rogers_park)
```

:::: {.columns}
::: {.column width = '50%'}
```{r boundary 2}
st_length(rogers_park)
```

:::

::: {.column width = '50%'}

```{r boundary 3, fig.align='center'}
nw <- filter(chi_neighb, pri_neigh %in% c('Edgewater', 'West Ridge'))
ggplot() + 
  geom_sf(data = nw) + 
  geom_sf_label(data = nw, aes(label = pri_neigh)) + 
  geom_sf(data = rogers_park) + 
  theme_void()
```

:::
::::

```{r}
rm(rogers_park, NU_campuses)
```

# Centroids 

> "the geometric center of mass of a geometry"     

```{r Centoid, echo = TRUE}
chi_cent <- st_centroid(chi_neighb)
```


```{r Centroid and POS Plot}

c_line <- st_linestring( 
    rbind(
      c(1,1), c(4,1), c(4,4),c(1,4)
    )
  )

c_polygon <- st_polygon( 
  list(
    rbind(
      c(1,1), c(4,1), c(4,4),c(1,4), 
      c(0.5, 4.5), c(4.5, 4.5), c(4.5, 0.5), c(0.5,0.5), c(1,1) 
    )
  )
)


c_line_cen <- st_centroid(c_line)
c_poly_cen <- st_centroid(c_polygon)
c_line_pos <- st_point_on_surface(c_line)
c_poly_pos <- st_point_on_surface(c_polygon)

a <- ggplot(c_line) +
  geom_sf()+
  geom_sf(data = c_line_cen, size = 4, color = 'red') +
  labs(title = 'Centroid') +
  theme_void()

b <- ggplot(c_polygon) +
  geom_sf() +
  geom_sf(data = c_poly_cen, size = 4, color = 'red') +
  theme_void()

c <- ggplot(c_line) +
  geom_sf()+
  geom_sf(data = c_line_pos, size = 4, color = 'red') +
  labs(title = 'Point on Surface') +
  theme_void()

d <- ggplot(c_polygon) +
  geom_sf() +
  geom_sf(data = c_poly_pos, size = 4, color = 'red') +
  theme_void()

```

```{r Neighborhood Centroids, out.width="50%", fig.align="center"}
ggplot() +
  geom_sf(data = chi_neighb, fill = "#B3DDF2", color ="#FFFFFF") +
  geom_sf(data = chi_cent, color = "#FF0000") +
  labs(title = "Centroids of Neighborhoods") +
  theme_light() +
  theme(plot.title = element_text(hjust = 0.5))
```

## Point on Surface 

If the centroid would fall outside of a geometry, constrain it with `st_point_on_surface`   

```{r Centoid and POS, echo = TRUE}
chi_pos <- st_point_on_surface(chi_neighb)
```

```{r Point on Surface Plot, fig.align="center"}
cowplot::plot_grid(a, c, b,  d,  nrow = 2)

rm(chi_pos, chi_cent, a, b, c,d, c_line, c_polygon, c_line_cen, c_poly_cen, c_line_pos, c_line_pos)
```


# Combine & Union Features

- Retain geometry information, but simplify any attribute information  
- Useful for performing lower level spatial operations or cartography  

## Combine Features

- `st_combine` will form a multi* geometry 
  - Retain all geometries as a multipolygon collection
  - Lose the attributes of each feature 

```{r Combine and Union, echo = TRUE}
chi_combine <- st_combine(chi_neighb)
```

:::: {.columns}
::: {.column width = '50%'}
<font size="4">
```{r, echo = TRUE}
head(chi_neighb)
```

```{r, echo = TRUE}
head(chi_combine)
```
</font>
:::

::: {.column width = '50%'}

```{r Combine Plots, out.width = "95%", fig.align="center"}
ggplot() +
  geom_sf(data = chi_combine, fill = "#B3DDF2", color ="#FFFFFF") +
  labs(title = "Combine forms a Multipolygon without feature attributes") +
  theme_light() +
  theme(plot.title = element_text(hjust = 0.5))

rm(chi_combine)
```

:::
::::

## Union Features 

- `st_union` will form a multi* geometry
  - Retain only outer boundary geometries of features
  - Lose the attributes of each feature
  
```{r, echo = TRUE}
chi_union <- st_union(chi_neighb)
```
  
:::: {.columns}
::: {.column width = '50%'}
<font size="4">
```{r, echo = TRUE}
head(chi_neighb)
```

```{r, echo = TRUE}
head(chi_union)
```
</font>
:::

::: {.column width = '50%'}
```{r Union Plots, out.width = "95%", fig.align="center"}
ggplot() +
  geom_sf(data = chi_union, fill = "#B3DDF2", color ="#FFFFFF") +
  labs(title = "Union also forms a multi*polygon without feature attributes") +
  theme_light() +
  theme(plot.title = element_text(hjust = 0.5))
```
:::
::::

## `st_cast`

- Can be used to extract types of geometries from a multi(polygon, line, point)geometry, or geometry collection. 

```{r Cast 1, echo = F, message = F, warning = F, message = F, out.height="25%"}
nc = st_read(system.file("shape/nc.shp", package="sf"), quiet = T)
mpl <- nc$geometry[[4]]

cast_all <- function(xg) { # by Edzar
  lapply(c("MULTIPOLYGON", "MULTILINESTRING", "MULTIPOINT", "POLYGON", "LINESTRING", "POINT"), 
      function(x) st_cast(xg, x))
}

r <- st_sfc(cast_all(mpl))

a <- ggplot(r[[1]], fill = 'red') +
  geom_sf() +
  theme_void() +
  labs(title = class(r[[1]])[2])

b <- ggplot(r[[2]]) +
  geom_sf() +
  theme_void() +
  labs(title = class(r[[2]])[2])

c <- ggplot(r[[3]]) +
  geom_sf() +
  theme_void() +
  labs(title = class(r[[3]])[2])

d <- ggplot(r[[4]]) +
  geom_sf() +
  theme_void() +
  labs(title = class(r[[4]])[2])

e <- ggplot(r[[5]]) +
  geom_sf() +
  theme_void() +
  labs(title = class(r[[5]])[2])

f <- ggplot(r[[6]]) +
  geom_sf() +
  theme_void() +
  labs(title = class(r[[6]])[2])

cowplot::plot_grid(a,b,c,d,e,f)
rm(a,b,c,d,e,f, nc, mpl, cast_all)
```

- Divide a Multipolygon into individual polygons. 

```{r Cast 2, message = F, warning = F}
chi_sub <- chi_neighb[sample(size = 30, 1:nrow(chi_neighb)),]
chi_union <- st_union(chi_sub)
chi_cast <- st_cast(chi_union, to = "POLYGON")
```

::: {style="float: center; width: 100%; font-size: 0.8em; color: #cbc4c3; text-align: center;"}

```{r Cast 3, message = F, echo = F, out.width = "95%", fig.align="center"}

a <- ggplot() +
  geom_sf(data = chi_sub, fill = "#B3DDF2", color = "#FF0000") +
  labs(title = "Random Sample") +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5))

b <- ggplot() +
  geom_sf(data = chi_union, fill = "#B3DDF2", color = "#FF0000") +
  labs(title = "Union") +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5))

c <- ggplot() +
  geom_sf(data = chi_cast, fill = sf.colors(length(chi_cast), categorical = TRUE)) +
  labs(title = "Cast") +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5))

cowplot::plot_grid(a, b, c, ncol = 3)
```

```{r Cast 4, echo = F, message = F, warning = F, comment = "", fig.align='center'}
knitr::kable(head(chi_sub[,c(1,5)]), 
             col.names = c('Neighborhood', 'geometry'),
             caption = "Original data")

knitr::kable(chi_union, 
             caption = "Unioned Data")

knitr::kable(head(chi_cast), 
             caption = "Data Cast to Polygons")

rm(chi_sub, chi_cast, chi_union, a, b, c)
chi_union <- st_union(chi_neighb)
```

:::

## Buffers 

Enlarge a feature by a specified distance in X & Y dimensions 

```{r Buffer 1, echo = TRUE}
#| code-line-numbers: "3"
chi_union <- sf::st_transform(chi_union, 32616) # project into a planar system
# with constant units i.e. meters. 
chi_buffer_3k <- st_buffer(chi_union, dist = 3000)
```

```{r Buffer 2, out.width = "75%", fig.align="center"}
ggplot() +
  geom_sf(data = chi_buffer_3k, fill = "#FF0000") +
  geom_sf(data = chi_neighb, fill = "#B3DDF2", color ="#FFFFFF") +
  labs(title = "Chicago Buffered by 3 kilometers") +
  theme_light() +
  theme(plot.title = element_text(hjust = 0.5))
```

## Convex Hulls

- Convex Hull: Encapsulate a feature space  

```{r Buffer and Convex Hull 1, echo = TRUE}
chi_ch_by_neigh <- st_convex_hull(chi_neighb)
chi_ch_cit <- st_convex_hull(chi_union)
```

```{r Buffer and Convex Hull 3, out.width = "75%", fig.align="center"} 
ggplot() +
  geom_sf(data = chi_ch_cit, color = NA, fill = "#B3DDF2", lty = 5, line = 2) +
  geom_sf(data = chi_neighb, fill = 'white', border = NA, color = NA) +
  geom_sf(data = chi_ch_by_neigh,  fill = NA, lwd = 1) +
  labs(title = "Convex Hulls of Three Features") +
  theme_light() +
  theme(plot.title = element_text(hjust = 0.5))
  
rm(chi_buffer_3k, chi_ch_cit, chi_ch_buf, chi_union, chi_ch_by_neigh)
```

# Measuring Distances  

Earth is a ellipsoid, distances must be calculated along the earths curved surface

::: {style="float: left; width: 50%;"} 
$P$ Point of origin  
$Q$ destination  
$u$ & $v$ : antipodal points, positions across the ellipsoid from each other  
:::

::: {style="float: right; width: 50%; font-size: 0.6em; color: #cbc4c3; text-align: center;"}
```{r, out.width = "75%", fig.align="center", fig.show='hold', echo = F, fig.cap = "Great Circle Distance (ChecCheDaWaff)"}
knitr::include_graphics("../pictures/Great_Circle_Distance_CheCheDaWaff.png")
```
:::

## Measuring Distance II

`st_distance` will calculate distance between locations using great circle distance 

```{r Pairwise Distance example I, echo = TRUE}
AM_FM <- st_distance(AM, FM)
AM_FM <- as.numeric(units::set_units(AM_FM, 'kilometer')) 
```

```{r Pairwise Distance between three Natural History Museums 1}
AM_SM <- st_distance(AM, SM)
FM_SM <- st_distance(FM, SM)
```

```{r Pairwise Distance between three Natural History Museums 2, echo = F}
AM_SM <- as.numeric(units::set_units(AM_SM, 'kilometer'))
FM_SM <- as.numeric(units::set_units(FM_SM, 'kilometer'))
```

::: {style="float: left; width: 50%; font-size: 0.8em;"}

```{r Distance between three natural history museums 3, echo = F, fig.align='center'}
st_dist_results <- data.frame(rbind(
  c(AM_FM, 'American to Field'), 
  c(AM_SM, 'American to Smithsonian'),
  c(FM_SM, 'Field to Smithonian')
  )
)

colnames(st_dist_results) <- c('Distance_st', 'Journey')
st_dist_results$Distance_st <- round(as.numeric(st_dist_results$Distance_st), 1)

knitr::kable(st_dist_results, col.names = c("Distance (km)",'Journey'))
rm(AM_FM, AM_SM, FM_SM, st_dist_results)
```

:::

::: {style="float: right; width: 50%; font-size: 0.6em; color: #cbc4c3; text-align: center;"}

<br> 

```{r Create Plot of Great Circle Distances, echo = F, fig.align="center", out.width = "75%"}

# We can visualize this with some help from Charlie Joey Hadley who wrote some sf compliant great circle distance code

museums <- rbind(AM, FM, SM) %>%  # we want to map this
  mutate(
    across(
      .cols = c(latitude,longitude), 
      ~as.numeric(as.character(.x))
      )
    )
data(us_states) # we want to map this
us_states <- st_transform(us_states, st_crs(museums)) # we print museums and feed it into states.
bound <- st_bbox(st_buffer(museums, 450000))

journey_data <- as_tibble(rbind(cbind(AM, FM), 
                                cbind(AM, SM),
                                cbind(FM, SM))) %>% 
  mutate(journey = paste0(attribute, " to ", attribute.1)) %>% 
  dplyr::select(-attribute, -attribute.1, -geometry, -geometry.1) %>% 
  rename_with(.cols = everything(), ~ str_replace(.x, "1", "end")) %>% 
  mutate(across(.cols = latitude:longitude.end, ~as.numeric(as.character(.x))))

great_circle_routes <- journey_data %>% 
  journeys_to_sf() %>% 
  st_segmentize(units::set_units(100, km)) 

data(world)
world <- filter(world, name_long == 'Canada')

ggplot() +
  geom_sf(data = world) +
  geom_sf(data = us_states) +
  geom_sf(data = museums, size = 3) +
  geom_sf(data = great_circle_routes, lwd = 1) +
  coord_sf(xlim = c(bound[1],bound[3]), ylim = c(bound[2],bound[4])) +
  labs(title="Great Circle Distance Between Three Natural History Museums") +
  theme_light() +
  theme(plot.title = element_text(hjust = 0.5))
```

:::

```{r Length on Great Circle Distance Linestrings}
gcr_distance <- st_length(great_circle_routes)
```

```{r Clear environment after Great Circle, echo = F}
rm(AM, FM, SM, bound, museums, journey_data, great_circle_routes, gcr_distance, us_states, journeys_to_sf, world)
```

## Measuing Distances III 

We can measure distances between many objects and get a matrix of distances

```{r A dense distance matrix, echo = TRUE}
neighborhood_centroid_dist <- st_distance(
  st_centroid(chi_neighb) # st_distance requires points  
  )
```

```{r A dense distance matrix B, out.width = "75%", fig.align="center"}
neighborhood_centroid_dist <- units::drop_units(neighborhood_centroid_dist)
mean_distance <- colSums(neighborhood_centroid_dist)/(nrow(neighborhood_centroid_dist)-1)
chi_neighb1 <- cbind(chi_neighb, mean_distance) 
```

::: {style="float: left; width: 50%;"} 
<font size = "5">
```{r distance table}
chi_neighb1 %>% 
  st_drop_geometry() %>% 
  arrange(mean_distance) %>% 
  slice_head(n = 5) %>% 
  dplyr::select(pri_neigh, mean_distance) %>% 
  knitr::kable(
  caption = "The five most Central Chicago Neighborhoods ",
  col.names = c("Neighborhood",'Mean Distance (m)'))
```
</font>
:::

::: {style="float: right; width: 50%;"} 
```{r Distance plot}
ggplot() +
  geom_sf(data = chi_neighb1, aes(fill = mean_distance), alpha = 0.95) +
  scale_fill_viridis_c(option = "plasma") +
  labs(fill="Mean Distance (m)") +
  labs(title="Mean Distance Between all Neighborhoods in Chicago") +
  theme_light() +
  theme(plot.title = element_text(hjust = 0.5))
```
:::

```{r, echo = F, out.width = "75%", fig.align="center"}
rm(neighborhood_centroid_dist, mean_distance, chi_neighb1)
```

# An introduction to some types of Spatial Analyses

## Voronoi Polygons

Partition space to the closest object 

```{r Import example data, echo = F, comment = "", fig.align="center"}
plants <- read.csv("../spatial_lecture_data/Solidago_Erigeron_Lanphere.csv") %>% 
  st_as_sf(coords = c(y = 'longitude', x ='latitude'), crs = 4269, remove = F)  %>% 
  st_transform(32610) %>% 
  distinct(individual, .keep_all = T) %>% 
  filter(!individual %in% c(13, 43)) 
```

```{r Create Voronoi Polygons, echo = TRUE}
vorons <- st_voronoi(st_union(plants)) %>%  # need a multipoint object
  st_collection_extract() %>% # st_voronoi returns a multipolygon, extract
  st_as_sf(crs = 32610) # each of the polygons
```

::: {style="float: left; width: 55%;"} 

<br>

```{r, echo = TRUE}
vorons <- vorons %>% 
  mutate( # ancillary information 
    pt = unlist(st_intersects(plants, ,)), # match the input points to polygons
    area = as.numeric(st_area(.)), .before = 1 # calculate the area of each polygon
  )
```

:::

::: {style="float: right; width: 40%;"} 

<br>

```{r Plot voronoi polygons}
ggplot() +
  geom_sf(data = vorons, aes(fill = area), colour = 'grey60') +
  geom_sf(data = plants, shape = 19, colour = 'gold1') +
  coord_sf(ylim = c(4527046, 4527830), xlim = c(403150,403700))  + 
  labs(fill = bquote("Area"~ m^2), 
       subtitle = 'Voronoi Polygons', 
       title = "Areas closest to Observations") +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.x = element_text(angle = 45, vjust = 0.5)) 

rm(res, dat2, pols)
```

:::

## Identifying Distance Based Neighbors

- find neighbors via distance thresholds using `spdep`  
- neighbors can be used in spatial regression as weights 

```{r Distance Based Neighbors 1, echo = TRUE}
neighborhood_object <- dnearneigh(plants, d1 = 1, d2 = 200) 
```

::: {style="float: left; width: 50%;"} 

<font size="5">

```{r Distance Based Neighbors 2, echo = TRUE}
summary(neighborhood_object)
```

</font>

:::

::: {style="float: left; width: 50%;"} 

```{r Distance Based Neighbors 3,  fig.align="center"}

dat1 <- data.frame(
  cbind(
    plants$individual, 
    st_coordinates(plants)
  )
) |>
  setNames(c('individual', 'longitude', 'latitude'))

links <- neighborhood_object %>% 
  purrr::map(., as.integer) %>% 
  purrr::map(., as_tibble) %>% 
  map2_df(plants$individual, ~mutate(.x,Focal_id=.y)) %>% 
  rename(Neighbor = value) %>% 
  left_join(., dat1, by = c('Focal_id' = 'individual')) %>% 
  rename( 
    longitude.id = longitude,
    latitude.id = latitude) %>% 
  left_join(., dat1, by = c('Neighbor' = 'individual')) %>% 
  rename(
    longitude.nb = longitude,
    latitude.nb = latitude)  %>% 
  drop_na() %>% 
  mutate(Link = as.numeric(paste0(Focal_id, Neighbor)))

links <- as.matrix(links)
  
ex_linestring <- list(0)
for (i in 1:nrow(links)){
  ex_linestring[[i]] <- rbind(
        c(links[i, 3], links[i, 4]), 
        c(links[i, 5], links[i, 6]),
        c(links[i, 3], links[i, 4])
      )
}

ex_linestring <- lapply(ex_linestring, st_linestring)

link_collection <- ex_linestring %>%
  st_sfc(crs = 32610) %>%
  st_sf(geometry = .)

link_collection <-  link_collection %>% 
  mutate(length = as.numeric(st_length(link_collection))) %>% 
  filter(length >= 1 & length <= 200) 

ggplot() +
  geom_sf(data = link_collection, color = "lightblue2") + 
  geom_sf(data = plants, color = "darkorchid3", size = 1.5) + 
  coord_sf(ylim = c(4527046, 4527830), xlim = c(403150,403700)) + 
  labs(title = "Neighbors within 200 meters") + 
  theme_light() + 
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.x = element_text(angle = 45, vjust = 0.5)) 

rm(ex_linestring, neighborhood_object, i, links)
```

:::

## Kernel Density Estimation of a Point Pattern  

- estimate the *intensity*, ~ the density of a process in space
- more widely used for building models than simply estimating densities via projections

```{r Kernel Density of a Point Pattern Process, echo = F, fig.align="center"}
plants <- read.csv("../spatial_lecture_data/Solidago_Erigeron_Lanphere.csv") %>% 
  filter(longitude <= -124.1332, latitude >= 40.88581) %>% 
  st_as_sf(coords = c(y = 'longitude', x ='latitude'), crs = 4269)  %>% 
  st_transform(32610) %>% 
  distinct(individual, .keep_all = T) 

pp1 <- as.ppp(st_geometry(plants))
q <- density(pp1)

plot(density(pp1), main = "Intensity of a Plant Across a Landscape")

rm(q)
```

## Determine whether points have a non-random distribution  

```{r Cluster Points in Space Ripleys K, echo = TRUE}
ripleys_K <- Kest(pp1, correction="all")
```

::: {style="float: left; width: 50%;"} 

<font size ="6">
- Ripley's K  
  - Determine whether a point process has a non-random distribution  
  - Can fit multiple distributions  
  - models above the poisson curve have clustered distributions, below repelled  
  - processes which can be modelled  
</font>

:::

::: {style="float: right; width: 50%;"} 

<br> 
```{r Plot Ripleys K, out.width="95%", fig.align="center"}
plot(ripleys_K)
```

:::

## Cluster a Point Pattern  

- **D**ensity-**B**ased **S**patial **C**lustering of **A**pplications with **N**oise (DBSCAN).
- Algorithm for grouping objects in space 
- Developed in the mid 90's, still used and highly cited! 

- Requires two terms
  - minium points: the number of points required to form a cluster
  - eps: loosely related to distance for which neighbor searches can occur

## DBSCAN 

- `MinPts`: the number of points required to form a cluster
- `eps`: ~ distance for which neighbor searches occur
  
```{r, echo = TRUE }
clustered <- fpc::dbscan(st_coordinates(plants), eps = 70, MinPts = 3) 

plants <- mutate(plants, cluster = factor(clustered$cluster), 
       .before = geometry) # assign to sf object
```

```{r Cluster Points in Space - DBSCAN, echo = F, fig.align="center"}

hulls <- plants %>% 
  filter(cluster != 0) %>% 
  st_buffer(25) %>% 
  group_by(cluster) %>% 
  summarize(geometry = st_union(geometry)) %>% 
  st_convex_hull() %>% 
  mutate(cluster = as_factor(cluster))

ggplot() +
  geom_sf(data = hulls, aes(fill = cluster), alpha = 0.5) +
  geom_sf(data = plants,  color = "darkorchid3") +
  coord_sf(ylim = c(4527046, 4527830), xlim = c(403150,403700)) +
  scale_color_manual(values = c('#1b9e77','#d95f02','#d95f02','#e7298a'))+
  labs(title = "DBSCAN Clusters") +
  theme_light() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.x = element_text(angle = 45, vjust = 0.5))

rm(pp1, ripleys_K)
```


## Putting it all together 


::: {style="float: left; width: 45%;"} 
- Predicting population genetic structure
- Plants within clusters are likely to be more related to each other 
:::

::: {style="float: right; width: 55%;"} 
- Neighbors are more likely to be siblings 
- Gene banking of population should occur across cluster to maintain most diversity  
:::

```{r Visualize Clusters and Distance based Neighbors, fig.align="center"}
ggplot() +
  geom_sf(data = link_collection) +
  geom_sf(data = hulls, aes(fill = cluster), alpha = 0.5) +
  geom_sf(data = plants,  color = "darkorchid3") +
  coord_sf(ylim = c(4527046, 4527830), xlim = c(403150,403700)) +
  scale_color_manual(values = c('#1b9e77','#d95f02','#d95f02','#e7298a'))+
  labs(title = "DBSCAN Clusters with Neighbors") +
  theme_light() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.x = element_text(angle = 45, vjust = 0.5))
```


```{r Clear environment from main lecture, echo = F, warning = F, message = F}
rm(chi_neighb, clustered, dat1, hulls, link_collection, r, plants)
```

# Wrapping up the Spatial Data Science Module:

**Future Bonus SDS Office Hours**  
Wednesday Night at 5:00 - 6:00 in F-413.  

**Notes on this Lab**  
My lecture notes are in the R script I used to generate all of the novel figures for this presentation. This script is much longer and more complex than Lecture 1's script. Likewise this presentation is an .HTML file and can be launched from your computer (it was rendered directly from R using the script!). 

## Works Cited  

<font size="5">

Clementini, Eliseo; Di Felice, Paolino; van Oosterom, Peter (1993). "A small set of formal topological relationships suitable for end-user interaction". In Abel, David; Ooi, Beng Chin (eds.). Advances in Spatial Databases: Third International Symposium, SSD '93 Singapore, June 23–25, 1993 Proceedings. Lecture Notes in Computer Science. 692/1993. Springer. pp. 277–295. doi:10.1007/3-540-56869-7_16. ISBN 978-3-540-56869-8. Accessed 1.16.2021

Egenhofer, M.J.; Herring, J.R. (1990). "A Mathematical Framework for the Definition of Topological Relationships"

Ester, Martin; Kriegel, Hans-Peter; Sander, Jörg; Xu, Xiaowei (1996). Simoudis, Evangelos; Han, Jiawei; Fayyad, Usama M. (eds.). A density-based algorithm for discovering clusters in large spatial databases with noise. Proceedings of the Second International Conference on Knowledge Discovery and Data Mining (KDD-96). AAAI Press. pp. 226–231. CiteSeerX 10.1.1.121.9220. ISBN 1-57735-004-9.

[gstat](https://cran.r-project.org/web/packages/gstat/vignettes/gstat.pdf) Accessed 1.21.2021

[spdep](https://cran.r-project.org/web/packages/spdep/vignettes/nb_sf.html) Accessed 1.17.2021

[Great Circle Distances](https://www.findingyourway.io/blog/2018/02/28/2018-02-28_great-circles-with-sf-and-leaflet/) Accessed 1.16.2021

[Point Pattern Analysis in R](https://mgimond.github.io/Spatial/point-pattern-analysis-in-r.html) Accessed 1.22.2022

[GGplot2 and sf](https://r-spatial.org/r/2018/10/25/ggplot2-sf-2.html) Accessed 1.22.2022

[An Introduction to Analysing Spatial Patterns](https://rstudio-pubs-static.s3.amazonaws.com/126356_ef7961b3ac164cd080982bc743b9777e.html)  Accessed 1.21.2022  

</font>

## Packages cited 

```{r Packages cited, comment = ""}
c("raster", "sp", "sf", "tidyverse", "terra", 'spData', 'spdep', 'gstat', 'spatstat', 'fields' ) %>%
  map(citation) %>%
  print(style = "text", na.print = '')
```